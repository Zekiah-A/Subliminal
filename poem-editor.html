<!DOCTYPE html>
<html>
<head>
    <title>Subliminal</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="./styles.css">
    <script src="./account.js"></script>
    <script src="./polyfill.js"></script> 
    <script src="./editor-document.js"></script>
    <script src="./Other/component-registrar.js"></script>
    <script src="./Other/notification-template.js"></script>
    <script src="./Other/server.js"></script>
    <style>
        #main {
            position: relative;
            box-shadow: gray 0px 0px 2px;
            border-radius: 4px;
            background-color: var(--background-opaque);
        }
        #editorCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: text;
        }
        #editorCanvas:focus {
            outline: none;
        }
        .tool {
            margin: 1px;
            height: 24px;
            max-width: 100%;
        }
        .text-tools {
            position: fixed;
            top: 146px;
            left: 16px;
            width: 160px;
            padding: 8px;
            border-radius: 8px;
            background-color: var(--button-transparent);
            backdrop-filter: blur(5px);
            z-index: 1;
            transition: height .5s;
        }
        .tools-collapsed {
            text-align: right;
            position: absolute;
            right: 16px;
            rotate: 180deg;
            transform: translateY(4px);
        }
        .tools-collapsed > svg {
            fill: var(--text-colour);
        }
        .text-tools[collapsed="true"] {
            height: 36px;
            overflow: hidden;
        }
        .text-tools[collapsed="true"] .tools-collapsed {
            rotate: 0deg;
        }

        #formattingToolbar {
            display: flex;
            padding-left: 8px;
            padding-right: 8px;
            padding-top: 1px;
            padding-bottom: 1px;
            column-gap: 8px;
            max-width: 100%;
            overflow-x: visible;
        }
        #formattingToolbar > div {
            height: 32px;
            width: 32px;
            min-width: 32px;
            line-height: 32px;
            text-align: center;
            border-radius: 4px;
            user-select: none;
            padding: 1px;
            transition: 50ms transform;
        }
        #formattingToolbar > div:active{
            transform: scale(0.98);
        }
        #formattingToolbar > div > div {
            background-color: var(--button-transparent);
            border-radius: 4px;
            pointer-events: none;
        }
        .separator {
            background: transparent;
            width: 1px !important;
            min-width: 1px !important;
            border-radius: 0px !important;
            opacity: 0.1;
            margin-left: 8px;
            margin-right: 8px;
            flex-grow: 1;
        }

        #poem-tags button {
            border-radius: 4px;
            margin: 2px;
        }

        #signCanvas {
            background: var(--button-opaque);
            width:50%;
            height:50%;
            border-radius:4px
        }
        .sign-container {
            display:flex;
            flex-direction:column;
            justify-content:center;
            align-content:center;
            row-gap:4px;
            align-items:center;
            user-select:none;
        }
        .sign-buttons {
            display:flex;
            column-gap:8px;
            width:50%;
        }
        .sign-buttons > div {
            flex-grow: 1;
        }

        #side {
            position: fixed;
            top: 130px;
            right: 0px;
            width: max(16%, 250px);
            padding: 8px;
            background-color: var(--button-transparent);
            backdrop-filter: blur(5px);
            box-shadow: 0px 0px 8px grey;
            z-index: 2;
            height: calc(100% - 146px);
            overflow-y: scroll;
            transition: .2s width, .2s padding-left, .2s padding-right, .2s box-shadow, .2s height;
        }

        #side[collapsed] {
            width: 0px;
            padding-left: 48px;
            padding-right: 0px;
            overflow: hidden;
            box-shadow: none;
            border-left: 2px solid gray;
            cursor: pointer;
            backdrop-filter: blur(5px);
            background: transparent;
            z-index: 0;
        }

        #side[collapsed] .side-close-button {
            display: none;
        }

        #side > :not(div[close]) {
            display: none;
        }

        #side[mode="upload"] > div[upload], #side[mode="rhyme"] > div[rhyme], #side[mode="coauthor"] > div[coauthor] {
            display: flex;
        }
        
        .side-content {
            display: flex;
            flex-direction: column;
            row-gap: 8px;
        }

        .side-close-button {
            width: 80%;
            height: 48px;
            border: 1px solid gray;
            position: relative;
            border-radius: 64px;
            align-self: center;
            margin-top: 32px;
            transition: .2s transform;
            cursor: pointer;
            display: block !important;
        }

        .side-close-button > svg {
            height: calc(100% - 16px);
            left: 50%;
            position: relative;
            transform: translateX(-50%);
            fill: gray;
            top: 8px;
        }

        .side-close-button:hover {
            transform: scale(1.1);
        }

        #sideRhymeMatches {
            display: flex;
            flex-direction: column;
            row-gap: 8px;
        }

        .management-button {
            position: relative;
            height: 32px;
            width: 100%;
            margin-top: 8px;
        }

        .button-tooltip {
            left: calc(-100% - 32px) !important;
        }

        .content-ghost {
            position: absolute;
            z-index: -1;
            opacity: 0.2;
            user-select: none;
            margin: 0px;
            opacity: 0.6;
            top: 28px;
            left: 10px;
        }

        /* patches for if the poem is in centre style */
        .centre > .content-ghost {
            width: 100%;
            margin-top: -18px;
        }

        .tool-header {
            background-color: var(--button-opaque);
            width: calc(100% - 16px);
            display: block;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        #loadedContainer {
            display: flex;
            flex-direction: column;
            row-gap: 5px;
            max-height: 512px;
            overflow-y: scroll;
            height: 512px;
            margin-bottom: 8px;
        }

        #summaryArea {
            min-height: 50px;
            width: calc(100% - 16px);
            height: 254px;
            resize: none;
            background: var(--button-opaque);
            border: none;
            outline: none;
            border-radius: 8px;
            font-family: Arial, Helvetica, sans-serif;
            padding: 8px;
            transition: .2s box-shadow;
        }

        #tagContainer {
            background: var(--button-opaque);
            border-radius: 8px;
            display: grid;
            grid-template-columns: 33% 33% 33%;
            padding: 8px;
            grid-template-rows: auto auto;
            grid-gap: 2px;
        }

        #tagContainer > div {
            border-radius: 4px;
            height:64px;
            background: lightgrey;
            padding: 4px;
            text-align: center;
            transition: .2s color;
        }

        #tagContainer > div:hover {
            background: linear-gradient(45deg, #b92a2a, #e914149c);
            color: white;
        }

        #tagContainer > div[add]:hover {
            background: linear-gradient(45deg, #2ab936, #26e9149c);
            color: white;
        }

        #tagContainer, #cWarningContainer, #summaryArea {
            transition: .2s box-shadow;
        }

        #summaryArea:hover, #tagContainer:hover, #cWarningContainer:hover {
            box-shadow: 0px 0px 8px darkgray;
        }

        #builtinFreePopup img {
            border-radius: 4px;
            max-width: 100%;
        }

        .background-grid {
            display: grid;
            grid-template-columns: auto auto auto;
            grid-gap: 4px;
        }

        .background-grid > div {
            position: relative;
            overflow: hidden;
        }

        .background-grid > div:hover > div {
            top: 50%;
        }

        .background-grid > div > div {
            position: absolute;
            top: 100%;
            width: 100%;
            height: 50%;
            overflow: hidden;
            transition: .2s top;
            background-color: var(--button-opaque);
            user-select: none;
            pointer-events: none;
        }

        .suggestions {
            width: 192px;
            position: absolute;
            background: #bdbdbd;
            z-index: 3;
            border-radius: 4px;
            top: 0px;
            display: flex;
            background-color: var(--button-transparent);
            flex-direction: column;
            border: 1px solid gray;
            overflow: clip;
            overflow-y: scroll;
        }

        .suggestions-item {
            padding: 8px;
            display: flex;
        }

        .suggestions-item > span:nth-child(1) {
            flex-grow: 1;
        }

        .suggestions-item > span:nth-child(2) {
            font-size: 10px;
            opacity: 0.6;
        }

        .online-editors {
            position: fixed;
            left: 16px;
            display: flex;
            flex-direction: column;
        }
    
        @media screen and (orientation:portrait) {
            #main {
                margin-bottom: 48px;
            }

            .text-tools {
                position: inherit !important;
                width: calc(100% - 12px);
            }

            #side {
                width: calc(100% - 12px);
                height: 60%;
                bottom: 0px;
                top: inherit;
                padding-top: 0px;
            }

            #side[collapsed] {
                height: 0px;
                padding-top: 48px;
                width: 100%;
                padding-left: 0px;
                padding-right: 0px;
                border-top: 2px solid gray;
                border-left: none;
                left: 0px;
                z-index: 0;
                cursor: pointer;
                overflow: clip;
            }

            .side-close-button {
                width: 60%;
            }

            #signCanvas {
                width: 100%;
            }

            .sign-buttons {
                width: 100%;
            }

            #formattingToolbar {
                overflow-x: scroll;
            }

            #loadedContainer {
                height: calc(100% - 96px);
                max-height: calc(100% - 96px);
            }

            .separator {
                background: var(--text-colour);
            }

            .background-grid {
                grid-template-columns: auto auto;
            }

            .online-editors {
                bottom: 8px;
                right: 8px;
                left: unset;
                z-index: 2;
            }
        }
    </style>
</head>
<body style="max-width: 100%; overflow-x: hidden; overflow-y: scroll;">
    <div id="licenseAgreePopup" class="popup" style="display: none;">
        <h2>License agreement:</h2>
        <p>All content on this site must be licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0, in order to make open source contribution easy, with the underlying source code used to format and display that content licensed under the GNU GPL-3 license. Summaries of these licenses are available at CC BY-NC-SA and GPL-3.</p>
        <p>By uploading your work to this site, you give consent for your poem to be licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0.</p>
        <p>You also agree to allow us permission to store and process your work. We can also accept no responsibility, if you write something that gets you in trouble with people you know, an institution, or local government, you agree that you WILLINGLY chose to upload it here. We accept no responsibility how your work is interpreted, and what consequences may or may not come as a result of it.</p>
        <p>You will always be the lone copyright owner of your work, we will never, ever take ownership of what you made from you, and we will always comply if you ask for your poem to be modified, and or taken down from this site.</p>
        <p>If you want to, you can <strong>sign</strong> your poem off below.</p>
        <div class="sign-container">
           <canvas height="96" width="256" id="signCanvas" onmousedown="signCanvasDown(event)" onmousemove="signCanvasDrag(event)" onmouseup="signCanvasUp(event)" ontouchstart="signCanvasDown(event)" ontouchmove="signCanvasDrag(event)" ontouchend="signCanvasUp(event)"></canvas>
            <div class="sign-buttons">
                <div class="popup-button" style="pointer-events: none; opacity: 0.2;">Smooth</div>
                <div class="popup-button" onclick="signContext.clearRect(0, 0, signCanvas.width, signCanvas.height);">Clear</div>
                <div class="popup-button" onclick="licenseAgreePopup.style.display = 'none'; signContext.clearRect(0, 0, signCanvas.width, signCanvas.height); uploadCurrent();">Submit</div>
            </div>
        </div>
        <p style="opacity:0.6;"><em>Please don't use a real signature you use on legal documents here. By pressing submit, you agree to all the terms stated above.</em></p>
    </div>

    <div id="builtinFreePopup" class="popup" style="display: none;">
        <h2>Built-in backgrounds:</h2>
        <p>These backgrounds are free for you to use to jazz up your poem's look! Drawn and shot by members of the subliminal team.</p>
        <div class="background-grid" onclick="
            if (event.target == this)
                return
            applyBuiltinBackground(event.target)
            builtinFreePopup.style.display = 'none'
        ">
            <div><img loading="lazy" src="./Resources/Backgrounds/ChilternsWalk.jpg"><div>Taken somewhere in the Chilterns, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/FinlandIntersection.jpg"><div>Taken at an intersection somewhere between Uusikaupunki and Helsinki, Finland.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/IsoBoy.jpg"><div>A fish that mysteriously disappeared the next day, Island near Uusikaupunki, Finland.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/LondonCity.jpg"><div>A bridge to the Tate, London, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/LondonStreets.jpg"><div>A day in the city, near Farringdon, London, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/Portheleven.jpg"><div>It took standing on a rock in the middle of the sea to get this, Portheleven, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/FalmouthShellCave.jpg"><div>A really old shell cave, in Gyllyngdune Gardens, Falmouth, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/SnowdoniaPath.jpg"><div>A long path to mount Snowdon (maybe), Wales, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/SnowdoniaQuarry.jpg"><div>A spooky snap of quarry taken from a moving vehicle, Snowdonia, Wales, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/SnowdoniaQuarry2.jpg"><div>A sunnier view of the massive quarry, Snowdonia, Wales, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/SnowdoniaQuarry3.jpg"><div>An atmospheric pee(a)k (punny) of a quarry, Snowdonia, Wales, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/UusikaupunkiHorsepower.jpg"><div>This boat certainly has more than 5 horsepower, Island near Uusikaupunki, Finland.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/YorkshireMoorRoad.jpg"><div>A long, long road, past field and moor, Yorkshire, UK.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/ChaosDrawing.png"><div>Chaos, for those who want to have a bit of zazz around their stuff.</div></div>
            <div><img loading="lazy" src="./Resources/Backgrounds/AbbstraktBird.png"><div>Is it a bird? Dog? A secret message of text? All we know is that this mascot is iconic.</div></div>
        </div>
    </div>

    <div id="loadPoemPopup" class="popup" style="display: none/*block;*/">
        <h2>Load poem:</h2>
        <input type="file" multiple="true" id="poemImportInput" accept=".json, .txt" style="display: none" />
        <div id="loadedContainer"></div>
        <div class="popup-button" style="margin-bottom: 8px;" onclick="
            poemImportInput.click() // TODO: Use new filesystem access API
            for (let file of poemImportInput.files) {
                let guid = newGuid()
                let reader = new FileReader()
                reader.onload = () => {
                    if (file.name.endsWith('.txt')) {
                        // TODO: Do a simple \n to our format replacement
                        let poemData = {
                            summary: '', //meta description
                            tags: '', //meta keywords
                            cWarning: false, //content warning
                            cWarningAdditions: '', //content warning additional notes
                            poemName: file.name.split('.txt')[0],
                            poemAuthor: 'Unknown', //poem header title
                            poemContent: reader.result, //poem html
                            pageStyle: 'poem-centre', //poem visual format
                            pageBackground: '' //poem background image
                        }

                        localStorage.setItem(guid, JSON.stringify(poemData))
                        loadKey(guid)
                    }
                    else if (file.name.endsWith('.json')) {
                        localStorage.setItem(guid, reader.result)
                        loadKey(guid)
                    }
                    else {
                        console.error('Uploaded poem was not a text (.txt) or JSON (.json) file, can not import!')
                    }

                    fetchStorage()
                    loadPoemPopup.style.display = 'none'
                }
                reader.readAsText(file)
            }
        ">Import from local file</div>
        <div class="popup-button" style="margin-top: 8px;" onclick="loadPoemPopup.style.display = 'none';">Done</div>
    </div>

    <div class="title-blur" style="z-index: 3;">
        <div style="display: flex;">
            <h2 id="poemName" onpaste="event.preventDefault()" onkeydown="
                if(event.key === 'Enter') {
                    event.preventDefault()
                    return false
                }
            " style="display: inline;flex-grow: 1;text-align: right;" contenteditable="true">Click On Me to Start Editing</h2>
            <h2 class="centre" style="display: inline;">&nbsp;- By&nbsp;</h2>
            <h2 id="poemAuthor" onpaste="event.preventDefault()" onkeydown="
                if(event.key === 'Enter') {
                    event.preventDefault()
                    return false
                }
            " style="display: inline;flex-grow: 1;text-align: left;" contenteditable="true">Click On Me to Start Editing</h2>
        </div>
        <hr>
        <div id="formattingToolbar">
            <div class="options-parent" style="width: 72px; min-width: 72px;" onclick="this.children[1].style.display = this.children[1].style.display == 'block' ? 'none' : 'block'" onblur="this.children[1].style.display = 'none'">
                <div>File ⯆</div>
                <div class="options" style="width: 140px;">
                    <div onclick="
					    params.delete('edit')
                        params.delete('append')
					    location.href = location.origin + '/poem-editor/' + params.toString()
                    ">Open new</div>
                    <div onclick="
                        downloadCurrent()
                        document.body.appendChild(createFromData('subliminal-notification', { message: 'Successfully downloaded poem data.' }))
                    ">Download poem</div>
                    <div onclick="
                        saveCurrent()
                        document.body.appendChild(createFromData('subliminal-notification', { message: 'Successfully saved poem' }))
                    ">Save poem</div>
                    <div onclick="loadPoemPopup.style.display = 'block'">Open another</div>
                    <div onclick="
                        if (!side.getAttribute('collapsed') && side.getAttribute('mode') == 'upload') {
                            licenseAgreePopup.style.display = 'block'
                        }
                        else {
                            side.setAttribute('mode', 'upload')
                            side.removeAttribute('collapsed')
                        }
                    ">Upload to site</div>
                </div>                
            </div>    
            <div onclick="format('undo', null)" style="width: 72px; min-width: 72px;"><div>↩ undo</div></div>
            <div onclick="format('redo', null)" style="width: 72px; min-width: 72px;"><div>redo ↪</div></div>
            <div onclick="editor.addStyle(styleCodes.bold)"><div style="font-weight: bold;">B</div></div>
            <div onclick="editor.addStyle(styleCodes.italic)"><div style="font-style: italic;">I</div></div>
            <div onclick="editor.addStyle(styleCodes.monospace)"><div style="font-family: monospace;">C</div></div>
            <div onclick="editor.addStyle(styleCodes.superscript)"><div>Sup</div></div>
            <div onclick="editor.addStyle(styleCodes.subscript)"><div>Sub</div></div>
            <div style="position: relative;">
                <input class="tool" oninput="
                    editor.addStyle(styleCodes.colour, parseInt(this.value.slice(1), '16'))
                    formattingColourRect.style.background = this.value" value="#000000"
                    style="opacity: 0; position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" type="color">
                <div id="formattingColourRect" style="background-color: black; width: calc(100% - 2px); height: calc(100% - 2px); margin: 1px;border-radius: 4px;"></div>
            </div>
            <div><div>🖼️</div></div>
            <div class="separator"></div>
            <div class="options-parent" style="width: 112px; min-width: 112px;" onclick="this.children[1].style.display = this.children[1].style.display == 'block' ? 'none' : 'block'" onblur="this.children[1].style.display = 'none'">
                <div>Page layout ⯆</div>
                <div class="options">
                    <div onclick="changePageStyle('poem-centre')">Poem centre</div>
                    <div onclick="changePageStyle('poem-centre-wide')">Poem wide</div>
                    <div onclick="changePageStyle('centre')">Centre</div>
                </div>                
            </div>
            <div class="options-parent" style="width: 112px; min-width: 112px;" onclick="this.children[1].style.display = this.children[1].style.display == 'block' ? 'none' : 'block'" onblur="this.children[1].style.display = 'none'">
                <div>Background ⯆</div>
                <div class="options">
                    <div onclick="document.body.style.background = ''">None</div>
                    <div onclick="document.body.style.background = `url(\'${prompt('Enter the background image URL')}\')`">From link</div>
                    <div style="opacity: 0.6;">Upload file</div>
                    <div onclick="builtinFreePopup.style.display = 'block';">Built-in free</div>
                </div>                
            </div>
            <div onclick="
                side.removeAttribute('collapsed')
                side.setAttribute('mode', 'rhyme')
            " style="width: 132px; min-width: 132px;"><div>Rhyme finder ➕</div></div>
            <div onclick="
                side.removeAttribute('collapsed')
                side.setAttribute('mode', 'coauthor')
            " style="width: 132px; min-width: 132px;"><div>AI coauthor ➕</div></div>
        </div>
        <hr>
    </div>

    <div id="editorsPopup" class="popup" style="display: none;">
        <h2>Find someone to invite</h2>
        <input type="text" placeholder="Search for user by username">
        <div id="editorsResults" style="height: 500px;"></div>
    </div>

    <div class="online-editors">
        Online editors:
        <div style="position: relative;margin-bottom: -16px; display: flex;">
            <img src="https://t3.ftcdn.net/jpg/03/64/62/36/360_F_364623623_ERzQYfO4HHHyawYkJ16tREsizLyvcaeg.jpg" style="border-radius: 100%;" width="64" height="64">
            <div style="padding: 4px;border-radius: 8px;background: linear-gradient(lightblue, blue);color: white;height: 16px;position: relative;align-self: center;">You</div>
        </div>
        <a href style="margin-top: 24px;" onclick="">+ Invite editor</a>
    </div>

    <div id="main" class="poem-centre">
        <div id="suggestions" class="suggestions" style="display: none;"><!--Rhyme suggestions--></div>
        <textarea id="editorInputCatcher" style="position: absolute; left: -10000px; top: -10000px; z-index: -1; opacity: 0; pointer-events: none;" hidden>
            <!--I am a hack to allow for mobile virtual keyboard and input because the virtual
            keyboard API has stupid restrictions on where you can use .show(). I LoVe BROWSERS!!!!! 🥲🔫🔫🔫:)))-->
        </textarea>
        <canvas id="editorCanvas" tabindex="-1" virtualkeyboardpolicy="manual" onmousedown="
            this['pressed'] = true
            editor.clearSelection()
            editor.position = editor.realToTextPosition(event.offsetX, event.offsetY, this)
            editor.renderCanvasData(this)
            editorInputCatcher.focus()
            // TODO: handle virtkeyboard geometry in scrolldown
            //navigator.virtualKeyboard?.overlaysContent = true
            navigator.virtualKeyboard?.show()
        " onmousemove="
            if (this['pressed']) {
                let endPosition = editor.realToTextPosition(event.offsetX, event.offsetY, this)
                editor.selection.position = editor.position > endPosition ? endPosition : editor.position
                editor.selection.end = editor.position > endPosition ? editor.position : endPosition
                editor.renderCanvasData(this)
            }
        " onmouseup="this['pressed'] = false" onkeydown="
            if (event.key == 'Backspace') {
                editor.deleteText()
            }
            else if (event.key == 'Delete') {
                editor.deleteText(-1)
            }
            else if (event.key == 'Enter') {
                editor.addNewLine()
                // TODO: only scroll down if cursor becomes off the screen
                setTimeout(() => window.scrollTo(0, 1e5), 10)
            }
            else if (event.key == 'Shift' || event.key.length > 1) {
                return
            }
            else if (event.ctrlKey && event.key.toLowerCase() == 'a') {
                editor.selectAll()
            }
            else {
                editor.addText(event.key)
            }

            editor.renderCanvasData(this)
            event.preventDefault()
        " onblur="editor.renderCanvasData(this, false)" onfocus="editor.renderCanvasData(this)"></canvas>
    </div>

    <div id="side" class="document-tools" collapsed="false" mode="upload" onclick="
        if (side.getAttribute('collapsed'))
            side.removeAttribute('collapsed')
    ">
        <div class="side-content" upload>
            <div>
                <div style="display: flex;flex-direction: row;height: 48px;">
                    <p style="margin: 0px; align-self: center;">Poem summary:</p>
                </div>
                <textarea id="summaryArea" type="text" maxlength="160"></textarea>
            </div>
            
            <div>
                <div style="display: flex;flex-direction: row;height: 48px;">
                    <p style="margin: 0px; align-self: center;">Poem tags:</p>
                </div>

                <div id="tagContainer">
                    <div add="true" style="line-height: 64px;" onclick="addPoemTag(window.prompt('Enter tag you would like to add'))">+</div>
                </div>
            </div>

            <div>
                <div style="display: flex;flex-direction: row;height: 48px;">
                    <p style="margin: 0px; align-self: center;">Content Warning:</p>
                </div>

                <div id="cWarningContainer" style="background: var(--button-opaque);border-radius: 8px; padding: 8px;">
                    <input type="checkbox" id="cWarningCheckbox" onclick="cWarningNotesInput.disabled = this.checked ? false : true">
                    <label for="cWarningCheckbox"> Enabled</label>
                    <input type="text" id="cWarningNotesInput" class="popup-input" placeholder="Additional warning notes" style="width: calc(100% - 16px); height: 24px;" disabled="">
                </div>
            </div>

            <div class="popup-button" style="flex-grow: inherit;" onclick="
                licenseAgreePopup.style.display = 'block'
            ">Upload to site</div>
        </div>
        <div class="side-content" rhyme>
            <p>Poem Rhyme finder:</p>
            <input id="rhymeFinderInput" style="font-size: 16px; " type="text" class="popup-input" placeholder="Enter word">
            <p style="opacity: 0.6; font-size: 10px;">Use * to match any word ending, or ?? to match anything within a word, for example pai* (paint, pain), p???t (paint, print)</p>
            <div class="options-parent" onclick="this.children[1].style.display = this.children[1].style.display == 'block' ? 'none' : 'block'" onblur="this.children[1].style.display = 'none'">
                <div>Word search type ⯆</div>
                <div class="options" style="display: none;" onclick="
                    this.querySelector('[selected]')?.removeAttribute('selected')
                    if (event.target == this || !rhymeFinderInput.value)
                        return
                    event.target.setAttribute('selected', true)
                    rhymeFinderFind(rhymeFinderInput.value, event.target.dataset.api)
                ">
                    <div data-api="ml">Similar meaning</div>
                    <div data-api="sl">Sound like</div>
                    <div data-api="sp">Spelled similarly</div>
                    <div data-api="rel_jjb">Adjectives used to describe</div>
                    <div data-api="rel_jja">Nouns described by</div>
                    <div data-api="rel_rhy">Perfect rhymes</div>
                    <div data-api="rel_nry">Half rhymes</div>
                    <div data-api="rel_nry">Homophones</div>
                    <div data-api="rel_ant">Antonyms</div>
                    <div data-api="rel_nry">Matching consonant</div>
                </div>
            </div>
            <div id="sideRhymeMatches"><!--Container for side rhyme match elements--></div>
            <p style="opacity: 0.6; font-size: 10px;">Credits to datamuse for their fantastic API. https://www.datamuse.com/</p>
        </div>
        <div class="side-content" coauthor>
            <p>Poem AI coauthor:</p>
            <span style="opacity: 0.6;">Use the subliminal poem writing AI to help cowrite your work!</span>
            <div>
                Base the AI's results off of:
                <div id="sideAiBasisOptions" class="options-parent" style="display: inline;" onclick="this.children[1].style.display = this.children[1].style.display == 'block' ? 'none' : 'block'" onblur="this.children[1].style.display = 'none'">
                    <div>... ⯆</div>
                    <div class="options" style="display: none;" onclick="
                        if (event.target == this)
                            return
                        this.parentElement.children[0].innerText = event.target.innerText + ' ⯆'
                        this.parentElement.setAttribute('basis', event.target.dataset.basis)
                    ">
                        <div data-basis="my">My work so far</div>
                        <div data-basis="subliminal">Subliminal poems</div>
                    </div>
                </div>
            </div>
            <div class="popup-button" style="flex-grow: inherit;" onclick="alert('An error occurred - please try again later')">Start coauthor</div>
        </div>
        <div class="side-content" close>
            <div class="side-close-button" onclick="
                side.setAttribute('collapsed', true)
                side.setAttribute('mode', 'upload')
                event.stopPropagation()
            ">
                <svg xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20">
                    <path d="M18.442 2.442l-.884-.884L10 9.116 2.442 1.558l-.884.884L9.116 10l-7.558 7.558.884.884L10 10.884l7.558 7.558.884-.884L10.884 10l7.558-7.558z"></path>
                </svg>
            </div>
        </div>
    </div>

    <a href="../contents" style="z-index: 1;" class="back"> <- Back</a>
</body>
<script>
    const signContext = signCanvas.getContext("2d", { willReadFrequently: true })
    const params = new URLSearchParams(document.location.search)
    const edit = params.get("edit")
    const amend = params.get("amend")
    const decoder = new TextDecoder()
    const editorScale = 1.5
    const editor = new EditorDocument("Click On Me to Start Editing", editorScale, 18)
    let currentGuid = ""
    let poemTags = []
    let network = null

    // Make user confirm that they want to leave the page.
    window.onbeforeunload = () => true

    // format title to subliminal title format, used in poem download files, remove all non-fs friendly chars
    let formatDash = (text) => text.trim().toLowerCase()
        .replaceAll(" ", "-").replaceAll(/(^\.|[<>:"/\|?*])/g, "")

    // Save poem with a unique GUID so that we do not encounter overlaps 
    let newGuid = () => ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, char =>
                        (char ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> char / 4).toString(16))

    let pageToHtml = (text) => {
      let htmlObject = document.createElement('body')
      htmlObject.innerHTML = text
      return htmlObject
    }

    async function fetchStorage() {
        // Clear anything that may already be in the laoded container
        while (loadedContainer.firstChild) {
            loadedContainer.removeChild(loadedContainer.firstChild)
        }

        // Fetch poems in localstorage
        for (let i = 0; i < localStorage.length; i++) {
            if (localStorage.key(i).length != 36) {
                console.log(`Could not identify localStorage poem with key ${localStorage.key(i)} as a poem.`)
                continue
            }

            let current = JSON.parse(localStorage.getItem(localStorage.key(i)))
            let cardEl = document.createElement("div")
            cardEl.className = "poem-card"
            cardEl.onclick = () => {
                loadKey(localStorage.key(i))
                loadPoemPopup.style.display= "none"
            }

            let cardTitle = document.createElement("h4")
            cardTitle.textContent = current.poemName
            cardEl.appendChild(cardTitle)

            let cardPreview = document.createElement("p")
            cardPreview.className = "poem-preview"
            let pContent
            try {
                pContent = current.poemContent
            }
            catch (e) {
                continue
            }
            cardPreview.textContent = pContent

            cardEl.appendChild(cardPreview)
            loadedContainer.appendChild(cardEl)
        }

        // If logged in, try to fetch poems from the subliminal cloud
        if (localStorage.code) {
            let draftPoemIds = await getAccountData().draftPoemIds
            
            for (let id of draftPoemIds) {
                let draft = await executeAccountAction(actionType.GetDraft, id).json()
                let cardEl = document.createElement("div")
                cardEl.className = "poem-card"

                cardEl.onclick = async () => {
                    load(await executeAccountAction(actionType.GetDraft, id).json())
                    loadPoemPopup.style.display= "none"
                }

                let cardTitle = document.createElement("h4")
                cardTitle.textContent = draft.poemName
                cardEl.appendChild(cardTitle)
                
                let cardPreview = document.createElement("p")
                cardPreview.className = "poem-preview"
                cardPreview.textContent = draft.poemContent
            }
        }
    }

    function saveCurrent() {
        let saveData = {
            summary: summaryArea.value, //meta description
            tags: poemTags.toString(), //meta keywords
            cWarning: cWarningCheckbox.checked, //content warning
            cWarningAdditions: cWarningNotesInput.value, //content warning additional notes
            poemName: poemName.innerText,
            poemAuthor: poemAuthor.innerText, //poem header title
            poemContent: editor.data, //poem html
            pageStyle: main.className, //poem visual format
            pageBackground: document.body.style.background //poem background image
        }

        currentGuid ||= newGuid()
        localStorage.setItem(currentGuid, JSON.stringify(saveData))

        //Refresh load box with latest poem.
        fetchStorage()
    }

    function loadKey(key) {
        currentGuid = key
        let poemJson = JSON.parse(localStorage.getItem(key))
        load(poemJson)
    }

    function load(poemJson) {
        poemTags = []
        while (!tagContainer.lastElementChild.getAttribute("add")) {
            tagContainer.removeChild(tagContainer.lastElementChild)
        }

        if (poemJson.tags) {
            for(let tag of poemJson.tags?.split(",")) {
                addPoemTag(tag)
            }
        }

        summaryArea.value = poemJson.summary ?? ""
        cWarningCheckbox.checked = poemJson.cWarning ?? ""
        cWarningNotesInput.disabled = !poemJson.cWarning
        cWarningNotesInput.value = poemJson.cWarningAdditions ?? ""
        poemName.innerText = poemJson.poemName ?? "undefined"
        poemAuthor.innerText = poemJson.poemAuthor?? "undefined"
        editor.data = poemJson.poemContent ?? "undefined"
        document.body.style.background = poemJson.pageBackground ?? ""
        changePageStyle(poemJson.pageStyle ?? "poem-centre")
        editor.renderCanvasData(editorCanvas)
    }

    //This itelf is just the poem-editor, content will be moved from here to a new template file, and then downloaded
    function downloadCurrent() {
        saveCurrent()
        let el = document.createElement("a")
        el.setAttribute("href", "data:text/html;charset=UTF-8," + encodeURIComponent(localStorage.getItem(currentGuid)))
        el.setAttribute('download', formatDash(poemName.innerText) + ".json")
        el.style.display = "none"
        document.body.appendChild(el)
        el.click()
        document.body.removeChild(el)
    }

    // let number = 255
    // let gen = number
    // let shift = 0
    // gen ^= 1 << (7 - shift)
    // We pad the leading number because JS numbers can't have leading zeros
    // console.log(number.toString(2).padStart(8, 0) + " : " + gen.toString(2).padStart(8, 0) + " -> " + gen)
    function getSignCanvasBits() {
        let bufWidth = signCanvas.width / 8, bufHeight = signCanvas.height
        let buffer = new Uint8Array(bufWidth * bufHeight).fill(255) //11111111
        let data = signContext.getImageData(0, 0, signCanvas.width, signCanvas.height, { colorSpace: "srgb" }).data

        for (let h = 0; h < signCanvas.height; h++) {
            for (let w = 0; w < signCanvas.width; w++) {
                let byteI = Math.floor((signCanvas.width * h + w) / 8)
                let shiftI = w % 8

                // We use 4n (n = pixel iteration we are looking at) - 1 to get where 255 (for black) would be.
                // We set the bit to zero if the color at this position is not black
                if (data[4 * (signCanvas.width * h + w) + 3] == 0) buffer[byteI] ^= 1 << (7 - shiftI)
            }
        }

        return buffer
    }

    async function uploadCurrent() {
        saveCurrent()
        let loadObject = JSON.parse(localStorage.getItem(currentGuid))
        
        //Only apply if they actually used the signature
        let signBits = getSignCanvasBits()
        if (!signBits.every(item => item === 0)) {
            loadObject.signature = window.btoa(String.fromCharCode(...new Uint8Array(signBits)))
        }

        await upload(loadObject) 
    }

    async function upload(poemJson) {
        if (await isLoggedIn()) {
            poemJson.code = localStorage.accountCode
        }

        fetch(serverBaseAddress + "/PurgatoryUpload", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(poemJson)
        })
        .then(res => {
            if (!res.ok) {
                console.error("Cricical error in uploading" + res)
                licenseAgreePopup.style.display = "none"
                alert("Sorry!\n\nFailed to upload poem to purgatory. Maybe try again...")
                return null
            }

            return res.text()
        })
        .then(guidResponse => {            
            if (guidResponse == null) {
                return
            }

            console.log("Upload sucessful, redirecting.")
            window.onbeforeunload = () => {} 
            window.location.href = "./contents?purgatorynew=" + guidResponse
        })
    }

    function changePageStyle(newStyle) {
        main.className = newStyle
        editorCanvas.width = editorCanvas.offsetWidth * editorScale
        editor.renderCanvasData(editorCanvas)
    }

    // TODO : Update to editor document
    // PATCH: Stop pasting weird formatted text that could break things.
    function editorPaste(event) {
        console.error("editorPaste is deprecated, and is in need of updating. Please contact the developer.")
        return
        event.preventDefault()
        const text = event.clipboardData.getData('text/plain')
        text.replace("\n", "<br>")
        document.execCommand("insertText", false, text)
    }

    function applyBuiltinBackground(target) {
        if (!target.src) return
        document.body.style.background = `url('${target.src}')`
    }

    function addPoemTag(tagName) {
        if (!tagName || poemTags.includes(tagName) || poemTags.length >= 5) return
        tagname = tagName.toLowerCase().trim()
        poemTags.push(tagName)
        let newTag = document.createElement("div")
        newTag.innerText = tagName
        newTag.onclick = () => { removePoemTag(tagName) }
        tagContainer.appendChild(newTag)
    }

    function removePoemTag(tagName) {
        poemTags.splice(poemTags.indexOf(tagName), 1)
        for (let tag of tagContainer.children) {
            if (tag.innerText == tagName)
                tagContainer.removeChild(tag)
        }
    }

    function signCanvasDown(event) {
        let relativeX = (event.offsetX / signCanvas.offsetWidth * signCanvas.width)
        let relativeY = (event.offsetY / signCanvas.offsetHeight * signCanvas.height)
        this.down = true
        this.X = relativeX
        this.Y = relativeY
        this.color = 'rgb(0, 0, 0)'
        event.preventDefault()
    }

    function signCanvasUp(event) {
        this.down = false
        event.preventDefault()
    }

    function signCanvasDrag(event) {
        event.preventDefault()
        let relativeX = (event.offsetX / signCanvas.offsetWidth * signCanvas.width)
        let relativeY = (event.offsetY / signCanvas.offsetHeight * signCanvas.height)
        if (!this.down) return
        signContext.beginPath()
        signContext.moveTo(this.X, this.Y)
        signContext.lineCap = 'round'
        signContext.lineWidth = 3
        signContext.lineTo(relativeX , relativeY )
        signContext.strokeStyle = this.color
        signContext.stroke()
        this.X = relativeX
        this.Y = relativeY
    }

    async function fetchPathJson(path) {
        return await (await fetch((path.includes("/")
            ? window.location.origin
            : serverBaseAddress + "/Purgatory/") + path)).json()
    }

    async function amendMode() {
        loadPoemPopup.style.display = 'none'
        // TODO: Reimplement
        //originalContent.style.display = "block"
        //originalContent.style.top = content.offsetTop + "px"
        //originalContent.style.maxWidth = content.offsetWidth + "px"

        //Load up amendment poem
        let currentJson = await fetchPathJson(amend)
        //originalContent.innerHTML = currentJson.poemContent || ""
        currentJson.amends = amend
        load(currentJson)
    }

    async function rhymeFinderFind(word, apiPath) {
        let path = "https://api.datamuse.com/words?" + apiPath + "=" + word.replaceAll(" ", "+")
        if ((word.includes("*") || word.includes("?")) && apiPath != "sp") {
            path += "&sp=" + word
        }
        
        let response = await fetch(path)
        let matches = response.ok ? await response.json() : []
        
        while (sideRhymeMatches.lastElementChild) {
            sideRhymeMatches.removeChild(sideRhymeMatches.lastElementChild)
        }

        matches.sort((a, b) => a.score > b.score ? -1 : a.score == b.score ? 0 : 1)

        for (let match of matches) {
            let el = document.createElement("div")
            el.textContent = match.word
            let score = document.createElement("span")
            score.style.opacity = "0.6"
            score.textContent = " (" + match.score + " score)"
            el.appendChild(score)
            sideRhymeMatches.appendChild(el)
        }
    }
    
    async function getRhymes(word) {
        let response = await fetch("https:\/\/rhymebrain.com/talk?function=getRhymes&word=" + word)
        return response.ok ? await response.json() : []
    }

    async function getWordInfo(word) {
        let response = await fetch(" https://rhymebrain.com/talk?function=getWordInfo&word=" + word)
        return response.ok ? await response.json() : null
    }

    async function spawnRhymePopup(event) {
        const findWord = (text, position) => {
            const after = text.substring(position).match(/^[a-zA-Z0-9-_]+/)
            const before = text.substring(0, position).match(/[a-zA-Z0-9-_]+$/)
            return (before || "") + (after || "")
        }

        let offset = document.getSelection().baseOffset || document.getSelection().getRangeAt(0).startOffset
        let selectedWord = findWord(event.target.textContent, offset)
        let rhymes = await getRhymes(selectedWord)
        let selectedSyllables = (await getWordInfo(selectedWord))?.syllables || 2 
        if (offset == null || rhymes == null) return

        rhymes.sort((a, b) =>
            Math.abs(selectedSyllables - a.syllables) < Math.abs(selectedSyllables - b.syllables) ? -1 : 
            (Math.abs(selectedSyllables - a.syllables) == Math.abs(selectedSyllables - b.syllables)) ? 0 : 1)

        while (suggestions.lastElementChild) {
            suggestions.removeChild(suggestions.lastElementChild)
        }

        for (let rhyme of rhymes) {
            if (!rhyme.word || rhyme.word.length <= 1) continue
            let item = document.createElement("div")
            item.className = "suggestions-item"
            item.innerHTML = `<span>${rhyme.word}</span><span>(${rhyme.syllables} syllable${rhyme.syllables > 1 ? "s" : ""})</span>`
            suggestions.appendChild(item)
        }

        let item = document.createElement("div")
        item.className = "suggestions-item"
        item.innerHTML = `<span>❤️&nbsp;</span><span>All credits goes to rhymebrain for their fantastic API. https://rhymebrain.com</span>`
        suggestions.appendChild(item)

        suggestions.style.display = "block"
        suggestions.style.top = (event.offsetY + 48) + "px"
        suggestions.style.left = (event.offsetX + 16) + "px"
        suggestions.scrollTo(0, 0)
        suggestions.animate([
            { maxHeight: '0px' },
            { maxHeight: '256px' },
        ], {
            duration: 200,
            iterations: 1,
            fill: "both"
        })
    }

    function appendRhyme(event) {
        console.log(event)
    }

    async function editMode() {
        loadPoemPopup.style.display = 'none'
        let currentJson = await fetchPathJson(edit)
        currentJson.edits = edit
        load(currentJson)
    }

    if (amend) amendMode() //enter poem amendment mode
    else if (edit) editMode()
    else fetchStorage() //Load saved poems from local storage

    formattingToolbar.addEventListener("mousemove", event => {
        for (let button of formattingToolbar.children) {
            if (button.className == "separator") continue
            button.style.background =
                "radial-gradient(at left " + (event.screenX - button.offsetLeft) +
                "px top " + (event.screenY - button.offsetTop) + "px, darkgray, var(--background-opaque)"
        }
    })

    addEventListener("resize", event => {
        editorCanvas.width = editorCanvas.offsetWidth * editorScale
        editorCanvas.height = editorCanvas.offsetHeight * editorScale
        editor.renderCanvasData(editorCanvas)
    })

    // TODO: For some reason this does not work when I do it on the canvas itself
    addEventListener("keydown", event => {
        if (event.target != editorCanvas && event.target != editorInputCatcher) {
            return
        }

        event.preventDefault()
        if (event.key == "ArrowLeft" || event.key == "ArrowRight" || event.key == "ArrowUp" || event.key == "ArrowDown") {
            editor.movePosition(
                event.key == "ArrowLeft"
                ? positionMovements.left
                : event.key == "ArrowRight"
                ? positionMovements.right
                : event.key == "ArrowUp"
                ? positionMovements.up
                : positionMovements.down, event.shiftKey)
        }

        editor.renderCanvasData(editorCanvas)
    })
    
    editorCanvas.width = editorCanvas.offsetWidth * editorScale
    editorCanvas.height = editorCanvas.offsetHeight * editorScale
    editor.renderCanvasData(editorCanvas, false)
</script>
</html>
